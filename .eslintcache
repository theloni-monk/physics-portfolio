[{"C:\\Users\\Thelonious Cooper\\Documents\\GitHub\\physics-portfolio\\src\\index.js":"1","C:\\Users\\Thelonious Cooper\\Documents\\GitHub\\physics-portfolio\\src\\serviceWorker.ts":"2","C:\\Users\\Thelonious Cooper\\Documents\\GitHub\\physics-portfolio\\src\\App.tsx":"3","C:\\Users\\Thelonious Cooper\\Documents\\GitHub\\physics-portfolio\\src\\Home.tsx":"4","C:\\Users\\Thelonious Cooper\\Documents\\GitHub\\physics-portfolio\\src\\simulation\\index.ts":"5","C:\\Users\\Thelonious Cooper\\Documents\\GitHub\\physics-portfolio\\src\\PreviewCard.tsx":"6","C:\\Users\\Thelonious Cooper\\Documents\\GitHub\\physics-portfolio\\src\\simulation\\BlankTestSim.tsx":"7","C:\\Users\\Thelonious Cooper\\Documents\\GitHub\\physics-portfolio\\src\\simulation\\BasicParticleSim.tsx":"8","C:\\Users\\Thelonious Cooper\\Documents\\GitHub\\physics-portfolio\\src\\simulation\\OrbitSim.tsx":"9","C:\\Users\\Thelonious Cooper\\Documents\\GitHub\\physics-portfolio\\src\\simulation\\pegboardSim\\pegboardSim.tsx":"10","C:\\Users\\Thelonious Cooper\\Documents\\GitHub\\physics-portfolio\\src\\simulation\\utils\\vect.ts":"11","C:\\Users\\Thelonious Cooper\\Documents\\GitHub\\physics-portfolio\\src\\simulation\\GenericSim.tsx":"12","C:\\Users\\Thelonious Cooper\\Documents\\GitHub\\physics-portfolio\\src\\simulation\\pegboardSim\\Pegboard.ts":"13","C:\\Users\\Thelonious Cooper\\Documents\\GitHub\\physics-portfolio\\src\\simulation\\pegboardSim\\PegCollider.ts":"14","C:\\Users\\Thelonious Cooper\\Documents\\GitHub\\physics-portfolio\\src\\simulation\\pegboardSim\\BallCollider.ts":"15","C:\\Users\\Thelonious Cooper\\Documents\\GitHub\\physics-portfolio\\src\\simulation\\IDrawable.ts":"16"},{"size":609,"mtime":1615229339633,"results":"17","hashOfConfig":"18"},{"size":5444,"mtime":1612812178526,"results":"19","hashOfConfig":"18"},{"size":725,"mtime":1615229318099,"results":"20","hashOfConfig":"18"},{"size":1330,"mtime":1615229339605,"results":"21","hashOfConfig":"18"},{"size":269,"mtime":1614712225587,"results":"22","hashOfConfig":"18"},{"size":1040,"mtime":1615229339613,"results":"23","hashOfConfig":"18"},{"size":1281,"mtime":1612812178526,"results":"24","hashOfConfig":"18"},{"size":6720,"mtime":1615229339642,"results":"25","hashOfConfig":"18"},{"size":8493,"mtime":1615229339644,"results":"26","hashOfConfig":"18"},{"size":4578,"mtime":1615229339666,"results":"27","hashOfConfig":"18"},{"size":1256,"mtime":1614712272870,"results":"28","hashOfConfig":"18"},{"size":1329,"mtime":1612812178526,"results":"29","hashOfConfig":"18"},{"size":12867,"mtime":1615229339655,"results":"30","hashOfConfig":"18"},{"size":1606,"mtime":1615229339654,"results":"31","hashOfConfig":"18"},{"size":2182,"mtime":1615229339646,"results":"32","hashOfConfig":"18"},{"size":793,"mtime":1612812178526,"results":"33","hashOfConfig":"18"},{"filePath":"34","messages":"35","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},"lo5wc4",{"filePath":"37","messages":"38","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"39"},{"filePath":"40","messages":"41","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"39"},{"filePath":"42","messages":"43","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"39"},{"filePath":"44","messages":"45","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"39"},{"filePath":"46","messages":"47","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"48","usedDeprecatedRules":"39"},{"filePath":"49","messages":"50","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"39"},{"filePath":"51","messages":"52","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"53","usedDeprecatedRules":"39"},{"filePath":"54","messages":"55","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"39"},{"filePath":"56","messages":"57","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"39"},{"filePath":"58","messages":"59","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"39"},{"filePath":"60","messages":"61","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"39"},{"filePath":"62","messages":"63","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"64","usedDeprecatedRules":"39"},{"filePath":"65","messages":"66","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"39"},{"filePath":"67","messages":"68","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"39"},{"filePath":"69","messages":"70","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"C:\\Users\\Thelonious Cooper\\Documents\\GitHub\\physics-portfolio\\src\\index.js",[],["71","72"],"C:\\Users\\Thelonious Cooper\\Documents\\GitHub\\physics-portfolio\\src\\serviceWorker.ts",[],["73","74"],"C:\\Users\\Thelonious Cooper\\Documents\\GitHub\\physics-portfolio\\src\\App.tsx",[],"C:\\Users\\Thelonious Cooper\\Documents\\GitHub\\physics-portfolio\\src\\Home.tsx",[],"C:\\Users\\Thelonious Cooper\\Documents\\GitHub\\physics-portfolio\\src\\simulation\\index.ts",[],"C:\\Users\\Thelonious Cooper\\Documents\\GitHub\\physics-portfolio\\src\\PreviewCard.tsx",["75"],"import React, { Component } from 'react'\r\nimport { Route, Redirect } from \"react-router-dom\";\r\n\r\n\r\ninterface iprops{\r\n    link: string,\r\n    preview_img: any,\r\n    title: string,\r\n    description: string\r\n}\r\ninterface istate{\r\n    isClicked:boolean,\r\n    isHovered:boolean\r\n}\r\n\r\nexport default class PreviewCard extends Component<iprops,istate> {\r\n    constructor(props:iprops){\r\n        super(props);\r\n        this.state = {isClicked:false, isHovered:false};\r\n    }\r\n    render() {\r\n        //fuxk it write the hover css later stop being a dumbass\r\n        if(this.state.isClicked) return <Redirect to = {{pathname: this.props.link}} />\r\n        //TODO: add preview\r\n        return (\r\n            <div className='rounded-lg bg-purple-800 p-4 w-36 text-white m-3' onClick={(e) => this.setState({isClicked:true})}>\r\n                <div className = 'hover:underline'>{this.props.title}</div>\r\n                <div className= 'text-center text-blue-400'>{this.props.description}</div>\r\n            \r\n            </div>\r\n        );\r\n    }\r\n}\r\n","C:\\Users\\Thelonious Cooper\\Documents\\GitHub\\physics-portfolio\\src\\simulation\\BlankTestSim.tsx",[],"C:\\Users\\Thelonious Cooper\\Documents\\GitHub\\physics-portfolio\\src\\simulation\\BasicParticleSim.tsx",["76"],"import React,{Component} from 'react'\r\nimport * as PIXI from 'pixi.js'\r\nimport GenericSim from './GenericSim'\r\n\r\nimport Drawable, {screenBounds} from './IDrawable'\r\nimport DynamicBody from './IDynamicBody'\r\nimport Vector2 from './utils/vect'\r\n\r\nimport { Redirect } from 'react-router-dom'\r\ninterface iparticle extends DynamicBody,Drawable{};\r\n\r\nclass Particle implements iparticle{\r\n    pos:Vector2 \r\n    vel:Vector2 \r\n    acc:Vector2\r\n    g:PIXI.Graphics\r\n    constructor(p:Vector2,v:Vector2,a:Vector2){\r\n        this.pos = p;\r\n        this.vel = v;\r\n        this.acc = a;\r\n        this.g = new PIXI.Graphics();\r\n    }\r\n    setPos = (p:Vector2) => this.pos = p;\r\n    setVel = (v:Vector2) => this.vel = v;\r\n    setAcc = (a:Vector2) => this.acc = a;\r\n\r\n    /**@param t - time difference between update calls ; must be in seconds _not ms_ */\r\n    update(t:number){\r\n        this.pos = this.pos.add(this.vel.multScalar(t));\r\n        this.vel = this.vel.add(this.acc.multScalar(t));\r\n    }\r\n\r\n    posToPx(sb:screenBounds){\r\n        let scaleh = (sb.endY - sb.startY) / sb.screenHeight;\r\n        //what one px corresponds to\r\n        let scalew = (sb.endX - sb.startX) / sb.screenWidth;\r\n        \r\n        let px = ((this.pos.x - sb.startX) / scalew);\r\n        let py = ((-1 * (this.pos.y - sb.endY)) / scaleh);\r\n        return new Vector2(px,py);\r\n    }\r\n\r\n    draw(sb:screenBounds){\r\n        this.g.clear();\r\n        let pxPos:Vector2 = this.posToPx(sb);\r\n        // Circle\r\n        this.g.lineStyle(0); //lineStyle to zero so the circle doesn't have an outline\r\n        this.g.beginFill(0xDE3249, 1);\r\n        this.g.drawCircle(pxPos.x, pxPos.y, 20); //20px size is totally arbitrary but will be fine for now\r\n        this.g.endFill();\r\n    }\r\n    \r\n}\r\n\r\ninterface iprops{\r\n    title: string\r\n}\r\ninterface istate{\r\n    goBack:boolean,\r\n    paused:boolean,\r\n    dampingLevel: string\r\n}\r\nexport default class BasicParticleSim extends Component<iprops,istate> {\r\n    protected renderTarget: HTMLDivElement\r\n    protected G: PIXI.Graphics\r\n    protected app: PIXI.Application\r\n    protected prevUpdateTime:number\r\n    protected screen:screenBounds \r\n    protected timeoutPtr: any //weird js pointer type\r\n\r\n    readonly fps:number = 60;\r\n\r\n    protected title: string\r\n\r\n    /**UNIQUE SIM VARIABLES */\r\n    ball:Particle\r\n\r\n    constructor(props:iprops){\r\n        super(props);\r\n        this.state = {\r\n            goBack:false,\r\n            paused:false,\r\n            dampingLevel: '0.5'\r\n        }\r\n        //this.title = props.title\r\n        this.G = new PIXI.Graphics();\r\n    }\r\n\r\n    initPIXI = (backgroundColor:number) =>{\r\n        //TODO: on resize reinit application and reassign this.G\r\n        //FIXME: get accurate canvas size from dom\r\n        this.app = new PIXI.Application({\r\n\t\t\twidth: window.innerWidth ,//this.screen.screenWidth,\r\n\t\t\theight: window.innerHeight, // this.screen.screenHeight,\r\n\t\t\tbackgroundColor: backgroundColor,\r\n\t\t\tantialias: true\r\n\t\t});\r\n\t\tthis.renderTarget.appendChild(this.app.view);\r\n\t\tthis.app.start(); //start renderer internal update ticker;\r\n        this.app.stage.addChild(this.G);\r\n    }\r\n\r\n    componentDidMount(){\r\n        console.log(this.renderTarget.getBoundingClientRect())\r\n        this.screen = {\r\n            screenWidth: (window.innerWidth), //this.renderTarget.getBoundingClientRect().width,\r\n            screenHeight: window.innerHeight, //this.renderTarget.getBoundingClientRect().height, \r\n            startX: 0, endX: 15,\r\n            startY: 0, endY: 10\r\n        }\r\n        this.initPIXI(0); //black background\r\n        this.initSim()\r\n    }\r\n\r\n    initSim(){\r\n        if(this.timeoutPtr) clearTimeout(this.timeoutPtr);\r\n        if(this.ball) this.ball.g.clear();\r\n        this.ball = new Particle(\r\n            new Vector2(2,0), // pos (5,0)\r\n            new Vector2(3,7), // 3m/s horizontal 7m/s upward initial velocity\r\n            new Vector2(0,-10) // -10m/s/s downward acceleration due to gravity\r\n        );\r\n        this.app.stage.addChild(this.ball.g)\r\n        this.update();\r\n    }\r\n\r\n    draw = () =>{\r\n        this.ball.draw(this.screen)\r\n    }\r\n\r\n    update = () =>{\r\n        if(this.state.paused) {this.prevUpdateTime = Date.now(); return}\r\n        if(!this.prevUpdateTime) this.prevUpdateTime = Date.now();\r\n        let deltaT = (Date.now() - this.prevUpdateTime)/1000\r\n        /**UPDATE LOGIC */\r\n        this.ball.update(deltaT);\r\n        //constrain ball to window bounds in X\r\n        if(this.ball.pos.x<this.screen.startX || this.ball.pos.x > this.screen.endX){\r\n            this.ball.setAcc(new Vector2(0,0));\r\n            this.ball.setVel(new Vector2(0,0));\r\n        }\r\n        if(this.ball.pos.y<this.screen.startY){\r\n            this.ball.setPos(new Vector2(this.ball.pos.x, this.screen.startY)) // avoid double collision registration\r\n            this.ball.setVel(new Vector2(this.ball.vel.x,-this.ball.vel.y* (1 - Number(this.state.dampingLevel)/10))); // bounce off of floor\r\n        }\r\n\r\n        this.draw();\r\n        this.prevUpdateTime = Date.now();\r\n        this.timeoutPtr = setTimeout(this.update, 16.66); //~60fps\r\n    }\r\n\r\n    handlePress = (e:KeyboardEvent) => {\r\n\r\n    }\r\n\r\n    render() {\r\n        if(this.state.goBack) return <Redirect to = {{pathname:'/'}}/>\r\n        let component = this;\r\n\t\tdocument.addEventListener('keyup', (e) => { this.handlePress(e) });\r\n\t\treturn (\r\n            <div className =\"sim-wrapper\">\r\n                <div className = \"sim-header\">Basic Bouncing Ball</div>\r\n                <div className=\"sim-sidebar\" >\r\n                    <div className = \"back-butt\" onClick={(e)=>this.setState({goBack:true})}>back</div>\r\n                    <div className = \"pause-butt\" onClick = {(e)=>this.setState({paused:!this.state.paused})}>{!this.state.paused?'pause':'unpause'}</div>\r\n                    <div className = \"restart-butt\" onClick = {(e)=>this.initSim()}>restart</div>\r\n                    {/** this is where you place any misc inputs to your sim and bind them to state*/}\r\n                    <div className = \"num-input\">\r\n                        <em>damping level:</em>\r\n                        {/**TODO: make custom input component */}\r\n                        <input className = \"slider\" type=\"range\" min=\"0\" max=\"10\" value={this.state.dampingLevel} onChange={(v)=>this.setState({dampingLevel: v.target.value})}/>\r\n                    </div>\r\n                </div>\r\n                <div className = \"sim-content\" ref={(thisDiv: HTMLDivElement) => { component.renderTarget = thisDiv }}\r\n                        onMouseMove={(e) => {  }}\r\n                    />\r\n                <div className = \"sim-footer\">written by theo cooper</div>\r\n                \r\n            </div>\r\n\t\t);\r\n    }\r\n}\r\n","C:\\Users\\Thelonious Cooper\\Documents\\GitHub\\physics-portfolio\\src\\simulation\\OrbitSim.tsx",[],"C:\\Users\\Thelonious Cooper\\Documents\\GitHub\\physics-portfolio\\src\\simulation\\pegboardSim\\pegboardSim.tsx",[],"C:\\Users\\Thelonious Cooper\\Documents\\GitHub\\physics-portfolio\\src\\simulation\\utils\\vect.ts",[],"C:\\Users\\Thelonious Cooper\\Documents\\GitHub\\physics-portfolio\\src\\simulation\\GenericSim.tsx",[],"C:\\Users\\Thelonious Cooper\\Documents\\GitHub\\physics-portfolio\\src\\simulation\\pegboardSim\\Pegboard.ts",["77","78"],"import CircleCollider from '../ICircleCollider';\r\nimport BallColliderObject from './BallCollider';\r\nimport PegColliderObject from './PegCollider';\r\nimport Vector2 from '../utils/vect';\r\nimport { screenBounds } from '../IDrawable';\r\nimport * as PIXI from 'pixi.js'\r\n\r\nconst MIN_VEL = 0.0001;\r\nconst VEL_NOISE_MAX = 0.01;\r\nconst PEG_RAD = 0.2;\r\nconst BALL_RAD = 0.2;\r\nconst BALL_START_POS = new Vector2(0, -BALL_RAD - 0.001);\r\nconst BB_RESTITUTION = 0.8; //what factor of kinetic energy is preserved in ball-ball collision, aka  how bouncy balls are with each other\r\nconst BP_RESTITUTION = 0.7; //what factor of kinetic energy is preserved in ball-peg collision, aka  how bouncy balls are with pegs\r\n\r\n\r\n//locations are percentages down the field in x and y\r\nconst PEG_LOCS: Vector2[] = [\r\n    new Vector2(-0.8, 0.2), new Vector2(-0.6, 0.2), new Vector2(-0.4, 0.2), new Vector2(-0.2, 0.2), new Vector2(0, 0.2),new Vector2(0.8, 0.2), new Vector2(0.6, 0.2), new Vector2(0.4, 0.2), new Vector2(0.2, 0.2),\r\n    new Vector2(-0.9, 0.3), new Vector2(-0.7, 0.3), new Vector2(-0.5, 0.3), new Vector2(-0.3, 0.3), new Vector2(-0.1, 0.3),new Vector2(0.7, 0.3), new Vector2(0.5, 0.3), new Vector2(0.3, 0.3), new Vector2(0.1, 0.3),\r\n    new Vector2(-0.8, 0.4), new Vector2(-0.6, 0.4), new Vector2(-0.4, 0.4), new Vector2(-0.2, 0.4), new Vector2(0, 0.4),new Vector2(0.8, 0.4), new Vector2(0.6, 0.4), new Vector2(0.4, 0.4), new Vector2(0.2, 0.4),\r\n    new Vector2(-0.9, 0.5), new Vector2(-0.7, 0.5), new Vector2(-0.5, 0.5), new Vector2(-0.3, 0.5), new Vector2(-0.1, 0.5),new Vector2(0.7, 0.5), new Vector2(0.5, 0.5), new Vector2(0.3, 0.5), new Vector2(0.1, 0.5)\r\n];\r\n\r\nexport default class Pegboard {\r\n    stage: PIXI.Container\r\n\r\n    pegs: PegColliderObject[]\r\n    balls: BallColliderObject[]\r\n    allAtRest: boolean\r\n\r\n    xrange: number[];\r\n    yrange: number[];\r\n\r\n    constructor(stage: PIXI.Container, xrange: number[], yrange: number[]) {\r\n        this.stage = stage;\r\n        this.pegs = [];\r\n        this.balls = [];\r\n\r\n        this.xrange = xrange;\r\n        this.yrange = yrange;\r\n        let xlen = Math.abs(xrange[0]) + Math.abs(xrange[1]);\r\n        let ylen = Math.abs(yrange[0]) + Math.abs(yrange[1]);\r\n\r\n        PEG_LOCS.forEach(loc =>\r\n            this.pegs.push(new PegColliderObject(new Vector2(loc.x * xlen / 2, -loc.y * ylen), PEG_RAD)))\r\n\r\n        this.pegs.forEach(peg => this.stage.addChild(peg.g))\r\n\r\n        this.allAtRest = false;\r\n    }\r\n\r\n    draw = (sb: screenBounds) => {\r\n        this.pegs.forEach(peg => peg.draw(sb));\r\n        this.balls.forEach(ball => ball.draw(sb));\r\n    }\r\n\r\n    step = (deltaT: number) => {\r\n        //console.log('deltat', deltaT);\r\n        if (this.balls.length === 0) { return;}\r\n        let ballsAtRest = 0;\r\n        let rindex = 0;//jank asf method of checking balls against each other by refrence without duplicates\r\n        this.balls.forEach(ball => {\r\n            if (!ball.atRest) {\r\n\r\n                ball.update(deltaT);\r\n\r\n                this.pegs.forEach(peg => {\r\n                    if (ball.isOverlapping(peg)) { \r\n                        this.doBPCollision(ball, peg) }\r\n                });\r\n                // this.balls.slice(rindex + 1).forEach(oball => {\r\n                //     if (!oball.atRest) {\r\n                //         if (ball.isOverlapping(oball)) this.doBBCollision(ball, oball)\r\n                //     }\r\n                // })\r\n                // rindex++;\r\n                this.checkEdge(ball);\r\n                // check to see if all balls are at rest\r\n                if (ball.atRest) ballsAtRest++;\r\n\r\n            }\r\n        });\r\n        if (ballsAtRest === this.balls.length)\r\n            this.allAtRest = true;\r\n    }\r\n\r\n    spawnBall = () => {\r\n        this.balls.push(new BallColliderObject(BALL_START_POS, BALL_RAD));\r\n        this.stage.addChild(this.balls[this.balls.length - 1].g);\r\n        console.log('ball spawned');\r\n    }\r\n\r\n    checkEdge(ball: BallColliderObject) {\r\n        // reverse ball x vel and push out of wall if bumps into side wall\r\n        if (ball.pos.x - ball.radius < this.xrange[0]) {\r\n            ball.setVel(new Vector2(-ball.vel.x, ball.vel.y));\r\n            ball.setPos(new Vector2(this.xrange[0] + ball.radius + 0.001, ball.pos.y));\r\n        }\r\n        if (ball.pos.x + ball.radius > this.xrange[1]) {\r\n            ball.setVel(new Vector2(-ball.vel.x, ball.vel.y));\r\n            ball.setPos(new Vector2(this.xrange[1] - ball.radius + 0.001, ball.pos.y))\r\n        }\r\n\r\n        //bounce off of ceiling\r\n        if (ball.pos.y + ball.radius > this.yrange[1]) {\r\n            ball.setVel(new Vector2(ball.vel.x, -ball.vel.y));\r\n            ball.setPos(new Vector2(ball.pos.x, this.yrange[1] - ball.radius + 0.001))\r\n        }\r\n\r\n        //stop when hitting the floor\r\n        if (ball.pos.y < this.yrange[0]) {\r\n            ball.setVel(new Vector2(0, 0));\r\n            ball.atRest = true;\r\n        }\r\n    }\r\n\r\n    doBPCollision(ball: BallColliderObject, peg: PegColliderObject) {\r\n        // Get distances between the balls components\r\n        let distanceVect: Vector2 = ball.pos.sub(peg.pos);\r\n\r\n        // Calculate magnitude of the vector separating the balls\r\n        let distanceVectMag = distanceVect.length();\r\n\r\n        // Minimum distance before they are touching\r\n        let minDistance = ball.radius + peg.radius;\r\n\r\n        if (distanceVectMag < minDistance) {\r\n            //let distanceCorrection = (minDistance - distanceVectMag) / 2.0;\r\n            let d = distanceVect.copy();\r\n            let correctionVector = d.norm().multScalar(minDistance + 0.01);\r\n            ball.pos = ball.pos.add(correctionVector);\r\n\r\n            // get angle of distanceVect\r\n            let theta = distanceVect.radians();\r\n            // precalculate trig values\r\n            let sine = Math.sin(theta);\r\n            let cosine = Math.cos(theta);\r\n\r\n            /*\r\n             * bTemp will hold rotated ball poss. You just need to worry about bTemp[1]\r\n             * pos\r\n             */\r\n            let bTemp: Vector2[] = [new Vector2(0, 0), new Vector2(0, 0)]\r\n\r\n\r\n            /*\r\n             * this ball's pos is relative to the b2 so you can use the vector\r\n             * between them (bVect) as the reference point in the rotation expressions.\r\n             * bTemp[0].pos.x and bTemp[0].pos.y will initialize automatically to\r\n             * 0.0, which is what you want since b[1] will rotate around b[0]\r\n             */\r\n            bTemp[1] = new Vector2(cosine * distanceVect.x + sine * distanceVect.y, cosine * distanceVect.y - sine * distanceVect.x)\r\n\r\n            // rotate Temporary velocities\r\n            let vTemp: Vector2[] = [new Vector2(cosine * ball.vel.x + sine * ball.vel.y, cosine * ball.vel.y - sine * ball.vel.x),\r\n            new Vector2(cosine * peg.vel.x + sine * peg.vel.y, cosine * peg.vel.y - sine * peg.vel.x)];\r\n\r\n            /*\r\n             * Now that velocities are rotated, you can use 1D conservation of momentum\r\n             * equations to calculate the final vel along the x-axis.\r\n             */\r\n            let vFinal: Vector2[] = [\r\n                // final rotated vel for b[0]\r\n                new Vector2(((ball.mass - peg.mass) * vTemp[0].x + 2 * peg.mass * vTemp[1].x) / (ball.mass + peg.mass), vTemp[0].y),\r\n                // final rotated vel for b[0]\r\n                new Vector2(((peg.mass - ball.mass) * vTemp[1].x + 2 * ball.mass * vTemp[0].x) / (ball.mass + peg.mass), vTemp[1].y)\r\n            ];\r\n            // hack to avoid clumping\r\n            bTemp[0].add(new Vector2(vFinal[0].x, 0));\r\n            bTemp[1].add(new Vector2(vFinal[1].x, 0));\r\n\r\n            /*\r\n             * Rotate ball poss and velocities back Reverse signs in trig expressions\r\n             * to rotate in the opposite direction\r\n             */\r\n            // rotate balls\r\n            let bFinal: Vector2[] = [new Vector2(cosine * bTemp[0].x - sine * bTemp[0].y, cosine * bTemp[0].y + sine * bTemp[0].x),\r\n            new Vector2(cosine * bTemp[1].x - sine * bTemp[1].y, cosine * bTemp[1].y + sine * bTemp[1].x)];\r\n\r\n            // update ball to screen pos\r\n            ball.setPos(ball.pos.add(bFinal[0]));\r\n\r\n            // update velocities\r\n            //ball.setVel(new Vector2(cosine * vFinal[0].x - sine * vFinal[0].y, cosine * vFinal[0].y + sine * vFinal[0].x));\r\n\r\n            // if peg doesn't move then for KE to be preserved output vel mag must be the same as input, just rotated\r\n            ball.setVel(Vector2.fromPolar(ball.vel.length(), theta));\r\n\r\n            // prevent head on collision from resulting in perfect up and down bouncing\r\n            let velNoiseVect: Vector2 = new Vector2((Math.random()-0.5) * VEL_NOISE_MAX, Math.abs(Math.random() * VEL_NOISE_MAX));\r\n            ball.setVel(ball.vel.add(velNoiseVect).multScalar(BP_RESTITUTION));\r\n\r\n            //check if velocities are low enough to set the ball to rest\r\n            if (ball.vel.length() < MIN_VEL) {\r\n                ball.setVel(new Vector2(0, 0));\r\n                ball.atRest = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    doBBCollision(b1: BallColliderObject, b2: BallColliderObject) {\r\n        // Get distances between the balls components\r\n        let distanceVect: Vector2 = b1.pos.sub(b2.pos);\r\n\r\n        // Calculate magnitude of the vector separating the balls\r\n        let distanceVectMag = distanceVect.length();\r\n\r\n        // Minimum distance before they are touching\r\n        let minDistance = b1.radius + b2.radius;\r\n\r\n        if (distanceVectMag > minDistance) return;\r\n\r\n\r\n        //let distanceCorrection = (minDistance - distanceVectMag) / 2.0;\r\n        let d = distanceVect.copy();\r\n        let correctionVector = d.norm().multScalar(minDistance + 0.01);\r\n        b1.pos = b1.pos.add(correctionVector);\r\n\r\n        // get angle of distanceVect\r\n        let theta = distanceVect.radians();\r\n        // precalculate trig values\r\n        let sine = Math.sin(theta);\r\n        let cosine = Math.cos(theta);\r\n\r\n        /*\r\n         * bTemp will hold rotated ball poss. You just need to worry about bTemp[1]\r\n         * pos\r\n         */\r\n        let bTemp: Vector2[] = [new Vector2(0, 0), new Vector2(0, 0)]\r\n\r\n\r\n        /*\r\n         * this ball's pos is relative to the b2 so you can use the vector\r\n         * between them (bVect) as the reference point in the rotation expressions.\r\n         * bTemp[0].pos.x and bTemp[0].pos.y will initialize automatically to\r\n         * 0.0, which is what you want since b[1] will rotate around b[0]\r\n         */\r\n        bTemp[1] = new Vector2(cosine * distanceVect.x + sine * distanceVect.y, cosine * distanceVect.y - sine * distanceVect.x)\r\n\r\n        // rotate Temporary velocities\r\n        let vTemp: Vector2[] = [new Vector2(cosine * b1.vel.x + sine * b1.vel.y, cosine * b1.vel.y - sine * b1.vel.x),\r\n        new Vector2(cosine * b2.vel.x + sine * b2.vel.y, cosine * b2.vel.y - sine * b2.vel.x)];\r\n\r\n        /*\r\n         * Now that velocities are rotated, you can use 1D conservation of momentum\r\n         * equations to calculate the final vel along the x-axis.\r\n         */\r\n        let vFinal: Vector2[] = [\r\n            // final rotated vel for b[0]\r\n            new Vector2(((b1.mass - b2.mass) * vTemp[0].x + 2 * b2.mass * vTemp[1].x) / (b1.mass + b2.mass), vTemp[0].y),\r\n            // final rotated vel for b[0]\r\n            new Vector2(((b2.mass - b1.mass) * vTemp[1].x + 2 * b1.mass * vTemp[0].x) / (b1.mass + b2.mass), vTemp[1].y)\r\n        ];\r\n        // hack to avoid clumping\r\n        bTemp[0].add(new Vector2(vFinal[0].x, 0));\r\n        bTemp[1].add(new Vector2(vFinal[1].x, 0));\r\n\r\n        /*\r\n         * Rotate ball poss and velocities back Reverse signs in trig expressions\r\n         * to rotate in the opposite direction\r\n         */\r\n        // rotate balls\r\n        let bFinal: Vector2[] = [new Vector2(cosine * bTemp[0].x - sine * bTemp[0].y, cosine * bTemp[0].y + sine * bTemp[0].x),\r\n        new Vector2(cosine * bTemp[1].x - sine * bTemp[1].y, cosine * bTemp[1].y + sine * bTemp[1].x)];\r\n\r\n        // update ball to screen pos\r\n        b1.setPos(b1.pos.add(bFinal[0]));\r\n        b2.setPos(b2.pos.add(bFinal[1]));\r\n\r\n        // update velocities\r\n        b1.setVel(new Vector2(cosine * vFinal[0].x - sine * vFinal[0].y, cosine * vFinal[0].y + sine * vFinal[0].x));\r\n        b2.setVel(new Vector2(cosine * vFinal[1].x - sine * vFinal[1].y, cosine * vFinal[1].y + sine * vFinal[1].x));\r\n\r\n        //\r\n        b1.setVel(b1.vel.multScalar(BB_RESTITUTION));\r\n        b2.setVel(b2.vel.multScalar(BB_RESTITUTION));\r\n\r\n        //check if velocities are low enough to set the balls to rest\r\n        if (b1.vel.length() < MIN_VEL) {\r\n            b1.setVel(new Vector2(0, 0));\r\n            b1.atRest = true;\r\n        }\r\n        if (b2.vel.length() < MIN_VEL) {\r\n            b2.setVel(new Vector2(0, 0));\r\n            b2.atRest = true;\r\n        }\r\n\r\n    }\r\n}","C:\\Users\\Thelonious Cooper\\Documents\\GitHub\\physics-portfolio\\src\\simulation\\pegboardSim\\PegCollider.ts",[],"C:\\Users\\Thelonious Cooper\\Documents\\GitHub\\physics-portfolio\\src\\simulation\\pegboardSim\\BallCollider.ts",[],"C:\\Users\\Thelonious Cooper\\Documents\\GitHub\\physics-portfolio\\src\\simulation\\IDrawable.ts",[],{"ruleId":"79","replacedBy":"80"},{"ruleId":"81","replacedBy":"82"},{"ruleId":"79","replacedBy":"80"},{"ruleId":"81","replacedBy":"82"},{"ruleId":"83","severity":1,"message":"84","line":2,"column":10,"nodeType":"85","messageId":"86","endLine":2,"endColumn":15},{"ruleId":"83","severity":1,"message":"87","line":3,"column":8,"nodeType":"85","messageId":"86","endLine":3,"endColumn":18},{"ruleId":"83","severity":1,"message":"88","line":1,"column":8,"nodeType":"85","messageId":"86","endLine":1,"endColumn":22},{"ruleId":"83","severity":1,"message":"89","line":62,"column":13,"nodeType":"85","messageId":"86","endLine":62,"endColumn":19},"no-native-reassign",["90"],"no-negated-in-lhs",["91"],"@typescript-eslint/no-unused-vars","'Route' is defined but never used.","Identifier","unusedVar","'GenericSim' is defined but never used.","'CircleCollider' is defined but never used.","'rindex' is assigned a value but never used.","no-global-assign","no-unsafe-negation"]